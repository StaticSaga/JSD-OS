#ifndef STD_TYPE_TRAITS_H
#define STD_TYPE_TRAITS_H
namespace std {

	template<class T, T v>
	struct integral_constant 
	{
		static constexpr T value = v;
		using value_type = T;
		using type = integral_constant;
		constexpr operator value_type() const noexcept { return value; }
		constexpr value_type operator()() const noexcept { return value; } 
	};

	template<bool B, class T = void>
	struct enable_if {};

	template<class T>
	struct enable_if<true, T> { typedef T type; };

	template< bool B, class T = void >
	using enable_if_t = typename enable_if<B, T>::type;

	template< class T > struct remove_reference { typedef T type; };
	template< class T > struct remove_reference<T&> { typedef T type; };
	template< class T > struct remove_reference<T&&> { typedef T type; };

	template< class T >
	using remove_reference_t = typename remove_reference<T>::type;

	template <class _Tp> struct is_trivially_copyable
		: public integral_constant<bool, __is_trivially_copyable(_Tp)>
	{};

	template< class T >
	inline constexpr bool is_trivially_copyable_v = is_trivially_copyable<T>::value;

	template <class T> struct is_abstract
		: public integral_constant<bool, __is_abstract(T)> {};

	template <class T1, class T2> struct is_convertible
		: public integral_constant<bool, __is_convertible_to(T1, T2) &&
		!is_abstract<T2>::value> {};

	template <class From, class To>
	inline constexpr bool is_convertible_v = is_convertible<From, To>::value;

	template< class T >
	struct type_identity {
		using type = T;
	};

	template< class T > struct remove_cv { typedef T type; };
	template< class T > struct remove_cv<const T> { typedef T type; };
	template< class T > struct remove_cv<volatile T> { typedef T type; };
	template< class T > struct remove_cv<const volatile T> { typedef T type; };

	using false_type = integral_constant<bool, false>;
	using true_type = integral_constant<bool, true>;

	template< class T >
	using type_identity_t = typename type_identity<T>::type;

	template <class T> struct is_integral
		: integral_constant<bool, __is_integral(T)> {};

	template <class T>
	inline constexpr bool is_integral_v = __is_integral(T);

	template <typename T> struct is_floating_point
		: public integral_constant<bool, __is_floating_point(T)> {};
	
	template<typename T>
	inline constexpr bool is_floating_point_v = is_floating_point<T>::value;

	template<typename T>
	struct is_arithmetic : integral_constant<bool,
		is_integral<T>::value ||
		is_floating_point<T>::value> {};

	namespace detail {
		template<typename T, bool = is_arithmetic<T>::value>
		struct is_unsigned : integral_constant<bool, T(0) < T(-1) > {};

		template<typename T>
		struct is_unsigned<T, false> : false_type {};
	} // namespace detail

	template<typename T>
	struct is_unsigned : detail::is_unsigned<T>::type {};

	namespace detail {
		template<typename T, bool = is_arithmetic<T>::value>
		struct is_signed : integral_constant<bool, T(-1) < T(0) > {};

		template<typename T>
		struct is_signed<T, false> : false_type {};
	} // namespace detail

	template<typename T>
	struct is_signed : detail::is_signed<T>::type {};
}
#endif