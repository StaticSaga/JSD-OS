#ifndef STD_STRING_H
#define STD_STRING_H

#include <string.h>
#include <algorithm>
#include <type_traits>
#include <string_view>
#include <char_traits.h>

namespace std {
	template<typename C> class basic_string;

	using string = basic_string<char>;

	/*#define assert(expression)      \
				if(!(expression)) { \
					printf("%s %s %d\n", #expression, __FILE__, (unsigned)(__LINE__)); while(true);}
	*/
	#define assert(expression) 
};


template<typename CharT>
class std::basic_string
{
public:
	using value_type = CharT;
	using size_type = size_t;
	using iterator = value_type*;
	using const_iterator = const value_type*;
	using traits_type = char_traits<value_type>;
	static const size_type npos = -1;

	basic_string() noexcept
	{
		m_rep.s.size = 0;
		m_rep.s.data[0] = '\0';
		assert(!__is_long());
	}

	basic_string(const value_type* s) : basic_string(s, strlen(s))
	{
	}

	basic_string(const value_type* s, size_t len)
	{
		if(len > __min_cap - 1)
		{
			const auto new_cap = len + 1;
			m_rep.l.size = len;
			m_rep.l.data = new value_type[new_cap];
			__set_long_cap(new_cap);
			memcpy(m_rep.l.data, s, len);
			m_rep.l.data[len] = '\0';
			assert(__is_long());
		}
		else
		{
			m_rep.s.size = len;
			memcpy(&m_rep.s.data[0], s, len);
			m_rep.s.data[len] = '\0';
			assert(!__is_long());
		}
	}

	basic_string(const basic_string& str) : basic_string(str.data(), str.size())
	{
	}

	~basic_string()
	{
		if(__is_long())
			delete[] m_rep.l.data;
	}

	basic_string(basic_string&& str) noexcept
	{
		if(str.__is_long())
		{
			m_rep.l = str.m_rep.l;
			str.m_rep.s.size = 0;
			str.m_rep.s.data[0] = '\0';
			assert(__is_long());
			assert(!str.__is_long());
		}
		else
		{
			m_rep.s = str.m_rep.s;
			assert(!__is_long());
		}
	}

	basic_string& assign(const value_type* s)
	{
		const auto new_size = strlen(s);
		reserve(new_size);
		__copy_from_null_terminated_string(s, new_size);

		return *this;
	}

	basic_string& assign(const value_type* s, size_t n)
	{
		reserve(n);
		__copy_from_unterminated_string(s, n);

		return *this;
	}

	basic_string& assign(const basic_string& str)
	{
		const auto new_size = str.size();
		reserve(new_size);

		__copy_from_null_terminated_string(str.data(), new_size);

		return *this;
	}

	using __self_view = std::basic_string_view<CharT>;

	template <class Tp>
	struct __is_sv_convertible : public integral_constant<bool,
		is_convertible_v<const Tp&, __self_view> &&
		!is_convertible_v<const Tp&, const CharT*>> 
	{};

	struct __sv_wrapper
	{
		explicit __sv_wrapper(__self_view __ssv) noexcept : _sv(__ssv) { }
		__self_view _sv;
	};

	explicit basic_string(__sv_wrapper __sv)
		: basic_string(__sv._sv.data(), __sv._sv.size()) 
	{}

	template <class T, class = typename enable_if<__is_sv_convertible<T>::value>::type>
		explicit basic_string(const T& t) :
		basic_string(__sv_wrapper(t))
	{}

	template <class T, class = typename enable_if<__is_sv_convertible<T>::value>::type>
	basic_string& assign(const T& t)
	{
		__self_view sv = t;
		return assign(sv.data(), sv.size());
	}

	template <class T, class = typename enable_if<__is_sv_convertible<T>::value>::type>
	basic_string& operator=(const T& t)
	{
		__self_view sv = t;
		return assign(sv);
	}

	constexpr operator basic_string_view<CharT>() const noexcept
	{
		return basic_string_view<CharT>(data(), size());
	}

	basic_string& operator=(const value_type* str)
	{
		return assign(str);
	}

	basic_string& operator=(const basic_string& str)
	{
		return assign(str);
	}

	basic_string& operator=(basic_string&& str) noexcept
	{
		if(!str.__is_long())
		{
			__copy_from_null_terminated_string(str.data(), str.size());
		}
		else if(__is_long())
		{
			std::swap(m_rep.l, str.m_rep.l);
		}
		else if(&str != this)
		{
			m_rep.l = str.m_rep.l;
			str.m_rep.s.size = 0;
			str.m_rep.s.data[0] = '\0';
			assert(__is_long());
		}
		return *this;
	}

	iterator begin() noexcept
	{
		if(__is_long())
			return m_rep.l.data;
		else
			return &m_rep.s.data[0];
	}

	iterator end() noexcept
	{
		return begin() + size();
	}

	const_iterator cbegin() const noexcept
	{
		if(__is_long())
			return m_rep.l.data;
		else
			return &m_rep.s.data[0];
	}

	const_iterator cend() const noexcept
	{
		return cbegin() + size();
	}

	size_type size() const noexcept
	{
		if(__is_long())
			return m_rep.l.size;
		else
			return m_rep.s.size;
	}

	size_type length() const noexcept
	{
		return size();
	}

	size_type capacity() const noexcept
	{
		if(__is_long())
			return __get_long_cap() - 1;
		else
			return __min_cap - 1;
	}

	value_type& operator[](size_type n)
	{
		return begin()[n];
	}

	const value_type& operator[](size_type n) const
	{
		return cbegin()[n];
	}

	void reserve(size_type n = 0)
	{
		if(n > capacity())
		{
			const auto old_size = size();
			const auto new_cap = n + 1;
			value_type* new_ptr = new value_type[new_cap];
			memcpy(new_ptr, cbegin(), (old_size + 1) * sizeof(value_type));

			if(__is_long())
			{
				delete[] m_rep.l.data;
			}

			m_rep.l.data = new_ptr;
			m_rep.l.size = old_size;
			__set_long_cap(new_cap);
			assert(__is_long());
		}
	}

	const value_type* data() const noexcept
	{
		return cbegin();
	}

	const value_type* c_str() const noexcept
	{
		return cbegin();
	}


	void swap(basic_string& s) noexcept
	{
		std::swap(m_rep, s.m_rep);
	}

	void push_back(value_type c)
	{
		if(size() + 1 > capacity())
		{
			reserve(capacity() * 2);
		}
		if(__is_long())
		{
			m_rep.l.data[m_rep.l.size++] = c;
			m_rep.l.data[m_rep.l.size] = '\0';
		}
		else
		{
			m_rep.s.data[m_rep.s.size++] = c;
			m_rep.s.data[m_rep.s.size] = '\0';
		}
	}

	basic_string& append(const value_type* str, size_type count)
	{
		const auto new_size = size() + count;
		if(new_size > capacity())
		{
			reserve(new_size * 2);
		}
		assert(new_size <= capacity());
		memcpy(end(), str, count * sizeof(value_type));
		if(__is_long())
		{
			m_rep.l.size = new_size;
			m_rep.l.data[new_size] = '\0';
		}
		else
		{
			m_rep.s.size = new_size;
			m_rep.s.data[new_size] = '\0';
		}
		return *this;
	}

	basic_string& append(const value_type* str)
	{
		return append(str, strlen(str));
	}

	basic_string& append(const basic_string& str)
	{
		return append(str.data(), str.size());
	}

	basic_string& operator+=(const value_type* str)
	{
		return append(str);
	}

	basic_string& operator+=(const basic_string& str)
	{
		return append(str.data(), str.size());
	}

	basic_string& operator+=(value_type c)
	{
		push_back(c);
		return *this;
	}

	int compare(const value_type* s) const noexcept
	{
		return strcmp(c_str(), s);
	}

	int compare(const basic_string& s) const noexcept
	{
		size_type lhs_sz = size();
		size_type rhs_sz = s.size();
		int result = traits_type::compare(data(), s.data(), min(lhs_sz, rhs_sz));
		if(result != 0)
			return result;
		if(lhs_sz < rhs_sz)
			return -1;
		if(lhs_sz > rhs_sz)
			return 1;
		return 0;
	}

	bool empty() const noexcept
	{
		return size() == 0;
	}

	void pop_back()
	{
		if(__is_long())
		{
			--m_rep.l.size;
		}
		else
		{
			--m_rep.s.size;
		}
		*end() = '\0';
	}

	basic_string substr(size_t pos = 0, size_t count = npos) const
	{
		if(count == npos)
		{
			count = size() - pos;
		}
		return basic_string{cbegin() + pos, count};
	}

	size_t find_first_of(const basic_string& str, size_t pos = 0) const
	{
		for(auto it = cbegin() + pos; it < cend(); it++)
		{
			for(auto c = str.cbegin(); c < str.cend(); c++)
			{
				if(*c == *it)
					return it - cbegin();
			}
		}

		return npos;
	}

	constexpr size_t find(value_type c, size_t pos = 0) const noexcept
	{
		for(auto it = cbegin() + pos; it < cend(); it++)
		{
			if(c == *it)
				return it - cbegin();
		}

		return npos;
	}

	constexpr size_t find_first_of(value_type c, size_t pos = 0) const noexcept
	{
		return find(c, pos);
	}

	constexpr size_type find_last_of(value_type c,
									 size_type pos = npos) const noexcept
	{
		for(auto it = cend() - 1; it >= cbegin() + pos; --it)
		{
			if(c == *it)
				return it - cbegin();
		}

		return npos;
	}

	const value_type& back() const noexcept
	{
		return *(cend() - 1);
	}

	value_type& back() noexcept
	{
		return *(end() - 1);
	}

	void clear() noexcept
	{
		if(__is_long())
		{
			m_rep.l.size = 0;
			m_rep.l.data[0] = '\0';
		}
		else
		{
			m_rep.s.size = 0;
			m_rep.s.data[0] = '\0';
		}
	}

	void resize(size_t n)
	{
		reserve(n);
		if(n > size())
		{
			memset(end(), '\0', n - size());
		}
		if(__is_long())
		{
			m_rep.l.size = n;
			m_rep.l.data[n] = '\0';
		}
		else
		{
			m_rep.s.size = n;
			m_rep.s.data[n] = '\0';
		}
	}

private:

	void __copy_from_null_terminated_string(const value_type* data, size_type new_size) noexcept
	{
		assert(capacity() >= new_size);
		if(__is_long())
		{
			m_rep.l.size = new_size;
			memcpy(m_rep.l.data, data, (new_size + 1) * sizeof(value_type));
			assert(__is_long());
		}
		else
		{
			m_rep.s.size = new_size;
			memcpy(&m_rep.s.data[0], data, (new_size + 1) * sizeof(value_type));
			assert(!__is_long());
		}
	}

	void __copy_from_unterminated_string(const value_type* data, size_type new_size) noexcept
	{
		assert(capacity() >= new_size);
		if(__is_long())
		{
			m_rep.l.size = new_size;
			memcpy(m_rep.l.data, data, new_size * sizeof(value_type));
			m_rep.l.data[new_size] = '\0';
			assert(__is_long());
		}
		else
		{
			m_rep.s.size = new_size;
			memcpy(&m_rep.s.data[0], data, new_size * sizeof(value_type));
			m_rep.s.data[new_size] = '\0';
			assert(!__is_long());
		}
	}

	size_type __get_long_cap() const noexcept
	{
		return m_rep.l.cap & (size_type)(~__long_mask);
	}

	void __set_long_cap(size_type s) noexcept
	{
		m_rep.l.cap = __long_mask | s;
	}

	bool __is_long() const noexcept
	{
		return bool(m_rep.s.size & __short_mask);
	}

	struct __long
	{
		value_type* data;
		size_type size;
		size_type cap;
	};

	//#ifdef MACHINE_IS_BIG_ENDIAN
	//	static const size_type __short_mask = 0x01;
	//	static const size_type __long_mask = 0x1ul;
	//#else
	static const size_type __short_mask = 0x80;
	static const size_type __long_mask = ~(size_type(~0) >> 1);
	//#endif

	enum {
		__min_cap = (sizeof(__long) - 1) / sizeof(value_type) > 2 ?
		(sizeof(__long) - 1) / sizeof(value_type) : 2
	};

	struct __short
	{
		value_type data[__min_cap];
		unsigned char size;
	};

	struct __rep
	{
		union
		{
			__long  l;
			__short s;
		};
	};

	__rep m_rep;
};

template <typename C>
inline std::basic_string<C> operator+(	const std::basic_string<C>& lhs,
										const std::basic_string<C>& rhs)
{
	auto r = lhs;
	r += rhs;
	return r;
}

template <typename C>
inline bool operator==(const std::basic_string<C>& lhs,
					   const std::basic_string<C>& rhs)
{
	if(lhs.size() != rhs.size())
		return false;
	return lhs.compare(rhs) == 0;
}

template <typename C>
inline bool operator!=(const std::basic_string<C>& lhs,
					   const std::basic_string<C>& rhs)
{
	if(lhs.size() != rhs.size())
		return true;
	return lhs.compare(rhs) != 0;
}

template <typename C>
inline bool operator==(const std::basic_string<C>& lhs,
					   const typename std::basic_string<C>::value_type* rhs)
{
	return lhs.compare(rhs) == 0;
}

template <typename C>
inline bool operator!=(const std::basic_string<C>& lhs,
					   const typename std::basic_string<C>::value_type* rhs)
{
	return lhs.compare(rhs) != 0;
}

template <typename C>
inline bool operator==(const typename std::basic_string<C>::value_type* lhs,
					   const std::basic_string<C>& rhs)
{
	return rhs.compare(lhs) == 0;
}

template <typename C>
inline bool operator!=(const typename std::basic_string<C>::value_type* lhs,
					   const std::basic_string<C>& rhs)
{
	return rhs.compare(lhs) != 0;
}

template <typename C>
inline std::basic_string<C> operator+(const std::basic_string<C>& lhs,
									  const typename std::basic_string<C>::value_type* rhs)
{
	auto new_str = lhs;
	return new_str.append(rhs);
}
#endif

