#ifndef STD_ALGORITHM_H
#define STD_ALGORITHM_H

#include <utility>
#include <iterator>
#include <functional>

namespace std
{
template<class InputIt, class OutputIt>
constexpr OutputIt copy(InputIt first, InputIt last, OutputIt d_first)
{
	while(first != last)
	{
		*d_first++ = *first++;
	}
	return d_first;
}

template<class BidirIt1, class BidirIt2>
constexpr BidirIt2 copy_backward(BidirIt1 first, BidirIt1 last, BidirIt2 d_last)
{
	while(first != last)
	{
		*(--d_last) = *(--last);
	}
	return d_last;
}

template<class InputIt, class OutputIt, class UnaryPredicate>
constexpr OutputIt copy_if(InputIt first, InputIt last, OutputIt d_first,
						   UnaryPredicate pred)
{
	while(first != last)
	{
		if(pred(*first)) *d_first++ = *first;
		first++;
	}
	return d_first;
}

template<class InputIt, class OutputIt>
constexpr OutputIt move(InputIt first, InputIt last, OutputIt d_first)
{
	while(first != last)
	{
		*d_first++ = std::move(*first++);
	}
	return d_first;
}

template<class BidirIt1, class BidirIt2>
constexpr BidirIt2 move_backward(BidirIt1 first, BidirIt1 last, BidirIt2 d_last)
{
	while(first != last)
	{
		*(--d_last) = std::move(*(--last));
	}
	return d_last;
}

template<class ForwardIt, class T>
constexpr void fill(ForwardIt first, ForwardIt last, const T& value)
{
	for(; first != last; ++first)
	{
		*first = value;
	}
}

template<class InputIt1, class InputIt2, class BinaryPredicate>
constexpr bool equal(InputIt1 first1, InputIt1 last1, InputIt2 first2,
					 BinaryPredicate p)
{
	for(; first1 != last1; ++first1, ++first2)
	{
		if(!p(*first1, *first2))
		{
			return false;
		}
	}
	return true;
}

template<class T>
constexpr const T& min(const T& a, const T& b)
{
	return (b < a) ? b : a;
}

template<class T>
constexpr const T& max(const T& a, const T& b)
{
	return (b > a) ? b : a;
}

template<class T, class Compare>
constexpr const T& min(const T& a, const T& b, Compare comp)
{
	return (comp(b, a)) ? b : a;
}

template<class InputIt, class T>
constexpr InputIt find(InputIt first, InputIt last, const T& value)
{
	for(; first != last; ++first)
	{
		if(*first == value)
		{
			return first;
		}
	}
	return last;
}

template<class InputIt, class UnaryPredicate>
constexpr InputIt find_if(InputIt first, InputIt last, UnaryPredicate p)
{
	for(; first != last; ++first)
	{
		if(p(*first))
		{
			return first;
		}
	}
	return last;
}

template<class InputIt, class UnaryPredicate>
constexpr InputIt find_if_not(InputIt first, InputIt last, UnaryPredicate q)
{
	for(; first != last; ++first)
	{
		if(!q(*first))
		{
			return first;
		}
	}
	return last;
}

template<class ForwardIt>
constexpr ForwardIt max_element(ForwardIt first, ForwardIt last)
{
	if(first == last) return last;

	ForwardIt largest = first;
	++first;
	for(; first != last; ++first)
	{
		if(*largest < *first)
		{
			largest = first;
		}
	}
	return largest;
}

template<class ForwardIt, class Compare>
constexpr ForwardIt max_element(ForwardIt first, ForwardIt last, Compare comp)
{
	if(first == last) return last;

	ForwardIt largest = first;
	++first;
	for(; first != last; ++first)
	{
		if(comp(*largest, *first))
		{
			largest = first;
		}
	}
	return largest;
}

template<class ForwardIt, class T>
constexpr ForwardIt lower_bound(ForwardIt first, ForwardIt last, const T& value)
{
	ForwardIt it;
	typename iterator_traits<ForwardIt>::difference_type count, step;
	count = distance(first, last);

	while(count > 0)
	{
		it	 = first;
		step = count / 2;
		std::advance(it, step);
		if(*it < value)
		{
			first = ++it;
			count -= step + 1;
		}
		else
			count = step;
	}
	return first;
}

template<class ForwardIt, class T, class Compare>
constexpr ForwardIt lower_bound(ForwardIt first, ForwardIt last, const T& value,
								Compare cmp)
{
	ForwardIt it;
	typename iterator_traits<ForwardIt>::difference_type count, step;
	count = distance(first, last);

	while(count > 0)
	{
		it	 = first;
		step = count / 2;
		advance(it, step);
		if(cmp(*it, value))
		{
			first = ++it;
			count -= step + 1;
		}
		else
			count = step;
	}
	return first;
}

template<class ForwardIt1, class ForwardIt2>
constexpr void iter_swap(ForwardIt1 a, ForwardIt2 b) 
{
	std::swap(*a, *b);
}

template<class ForwardIt, class UnaryPredicate>
constexpr ForwardIt partition(ForwardIt first, ForwardIt last, UnaryPredicate p)
{
	first = find_if_not(first, last, p);
	if(first == last) return first;

	for(ForwardIt i = next(first); i != last; ++i)
	{
		if(p(*i))
		{
			iter_swap(i, first);
			++first;
		}
	}
	return first;
}

namespace __pvt
{
template<class It, class Compare = less<>>
constexpr void quick_sort(It first, It last, Compare cmp = Compare{})
{
	auto N = distance(first, last);
	if(N <= 1) return;
	auto pivot = *next(first, N / 2);
	auto middle1 =
		partition(first, last,
				  [pivot, cmp](const auto& elem) { return cmp(elem, pivot); });
	auto middle2 =
		partition(middle1, last,
				  [pivot, cmp](const auto& elem) { return !cmp(pivot, elem); });
	quick_sort(first, middle1, cmp);
	quick_sort(middle2, last, cmp);
}
}
template<class RandomIt, class Compare>
constexpr void sort(RandomIt first, RandomIt last, Compare cmp)
{
	__pvt::quick_sort(first, last, cmp);
}
}


#endif